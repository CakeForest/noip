/*
根据 题目，给出 p数列，要求 w数列。

我的思路是 根据 p 算出 每两个 右括号之间 有多少个 左括号，用 lp数组记录，然后 对每一个 右括号，往前搜索左括号
生成lp数组方法：
lp[i]=p[i]-p[i-1];
原因显而易见 
比如 p 4 5 6 6 6 6 ，那么 lp 值为 4 1 1 0 0 0
如此过后，lp[i]表示第i个右括号到第i-1个右括号之间的左括号数目；
接下来算w
w[i]意为第i个右括号匹配的括号中，右括号的数目（包括它本身）
则我们需要找到第i个右括号与哪一个左括号匹配；
匹配原则：就近匹配。
举例：
当lp的某一中间状态为 2 1 0时：
对于第一个右括号，它匹配的应该是第一个右括号前的一个左括号，因此w[1]=1-0=1（只有它本身）
此时lp应该变成：1 1 0（因为已经有一个括号用了）
第二个右括号，它匹配的应该是第一个右括号与第二个右括号间的一个左括号，因此w[2]=2-1=1(只有它本身）
此时lp应该变成：1 0 0
第三个右括号，它匹配的应该是第一个右括号前的的 一个左括号，因此w[3]=3-0=3
 
从第一个 右括号开始找，第一个对应 lp 第一个，发现lp不为 0 ，即将 lp-1，算出相应前面有多少个 右括号即可，若lp为 0 继续往前扫。。


*/ 

#include<cstdio>
#include<cstring>



int p[25]={0};
int lp[25];

int main(){
	int t;
	scanf("%d",&t);
	while(t--){
		int n;
		scanf("%d",&n);
		for(int i=1;i<=n;i++){
			scanf("%d",&p[i]);
		}
		for(int i=1;i<=n;i++){
			lp[i]=p[i]-p[i-1];
		}
		for(int i=1;i<=n;i++){
			int j=i;
			while(!lp[j]&&j>1){
				j--;
			}
			lp[j]--;
			printf("%d%c",i-j+1,i==n?'\n':' ');
		}
	}
	return 0;
}
